\chapter{Konzeptionierung}
\section{Beschreibung der Projekt-Basis}
\begin{itemize}
    \item Roboter aus 3D gedruckten Teilen
    \item 4 Beine mit 2 Teilen, d.h. 2 Gelenken pro Bein, eins im Bein und eins am Körper
    \item Gelenke sind Servos mit 120° Aktionsradius
    \item Neutralstellung ist Mitte des Servos, also 60°
    \item Steuerung über ESP8266 und Servo Breakout Board
    \item Stromversorgung über Batterie
    \item keine weitere Sensorik
    
    \item Simulation dieses Roboters in Unity
    \item dazu direkter Import des 3D Modells
    \item Software-Simulation der Servos und deren Charakteristika (Bewegungsgeschwindigkeit)
    \item ungefähres Gewicht der einzelnen Teile hinterlegen für Physiksimulation
\end{itemize}

Training:
\begin{itemize}
    \item Aufbauen von Wänden neben dem Roboter und Kollisionserkennung
    \item Entwerfen von Belohnungsfunktion für Fortschritt des Roboters
    \item Wenn umdrehen (auf Rücken wo Elektronik), bestrafen, sonst umso höher belohnen, umso weiter der Roboter in einer bestimmten Zeit kommt
    \item Klonen von mehreren Agenten in einer Umgebung
    \item Training
\end{itemize}

Übertragung:
\begin{itemize}
    \item Simulationsumgebung in Unity soll direkt Steuersignale an Roboter senden
    \item Roboter knickt unter Gewicht sofort ein und kann die gelernte Laufmethodik nicht anwenden
\end{itemize}

\section{Einschränkungen (und Übertragungsprobleme)}
\begin{itemize}
    \item bislang sollte der Roboter nur geradeaus laufen
    \item Roboter verfügt über keinerlei Sensorik
    \item kennt nur den aktuellen Winkel der Beine/Servomotoren
    \item Training erfolgte rein in der Simulation
    \item die Simulationsumgebung kennt den Zustand (z.B. Neigung) des Roboters und kann anhand dessen den Wert der Belohnungsfunktion berechnen und an den Roboter zurückmelden
    \item Roboter kennt seinen eigenen Zustand nicht
    \item bisheriges Modell wird lediglich in der Praxis angewandt, unter der Annahme, dass bei korrekt gelerntem Modell keinerlei Zusatzinformationen notwendig sind, um den Roboter seine Aufgabe erfüllen zu lassen: geradeaus zu laufen
\end{itemize}

Probleme in der erweiterten Aufgabenstellung:
\begin{itemize}
    \item der Roboter soll nun einem vorgegebenen Pfad folgen
    \item dabei soll der Pfad für jeden Durchlauf dem Roboter individuell vorgegeben werden können
    \item der Roboter soll NICHT einen vorgegebenen Pfad lernen und danach immer von diesem Pfad ausgehen
    \item dem Roboter muss also ein Pfad mitgegeben werden können
    
    \item Positionierungsinformationen benötigt?
    \item einerseits nein, theoretisch kann der Roboter seine aktuelle Position anhand seiner vergangenen Bewegungen vom Ausgangspunkt bestimmen
    \item andererseits ja, da der Roboter auf dem Boden rutschen kann (zumindest in der Realität), das Berechnen von Entfernungen den gesamten Algorithmus stark verkompliziert und unter Umständen durch kleinere Abweichungen sehr ungenau ausfallen kann
    \item mögliche Lösung in der Simulation: Positionierungsinformationen innerhalb der Simulationsumgebung für Roboter freigeben
    \item diese Informationen könnten dem Roboter später durch andere Sensoren geliefert werden
    \item wenn das Informationsformat des neuen Sensors umgewandelt wird in das bisherige Format (zum Beispiel durch ein externes Modul), könnte ein anderer Sensor Plug-And-Play in das trainierte Modell integriert werden
    
    \item außerdem soll der Roboter Hindernisse auf seinem Weg erkennen und gezielt umgehen können
    \item danach soll auf den Pfad zurückgekehrt werden
    \item dafür wird eine Hindernis-/Kollisionserkennung benötigt
    \item aktuell hat der Roboter keinerlei solche Sensorik
    \item vereinfacht soll für die Hinderniserkennung in der Simulation die Kollisionserkennung für die Beine verwendet werden
    \item dadurch muss der Roboter mit seinem Hindernis zusammenstoßen, um es wahrzunehmen
    \item in der Realität wäre natürlich eine Hinderniserkennung sinnvoll, mit der Hindernisse bereits vor einer Kollision erkannt werden können (z.B. LiDAR, Kameras oder ähnliche), die Integration solcher Systeme würde jedoch den Umfang dieser Arbeit erheblich übersteigen
    \item hier soll eher ein Proof-of-Concept für die selbstständige Umsteuerung von Hindernissen erarbeitet werden
    
    \item Genauigkeitsprobleme beim Übertragen der Springbewegung: daher genauere Einschränkungen für den Algorithmus
    \item bisher bewegt sich der Roboter nach Training in einer springenden Bewegung fort
    \item diese Bewegungsform ist sehr kraftaufwändig und instabil, der Roboter schwankt dabei stark um die horizontale Achse und kann seine exakte Landeposition nur bedingt steuern
    \item vor allem relevant, falls dem Roboter keine Positionierungsinformationen zur Verfügung gestellt würden, da dann jeder Millimeter zählt
    \item aber auch zur Erhöhung der allgemeinen Genauigkeit und Reduzierung der Fehler, wäre es sinnvoll, die Fortbewegung des Roboters zu stabilisieren
    \item mögliche Maßnahme zur Einschränkung der Bewegung: restriktive Anpassung der Belohnungsfunktion, wenn sich die Höhe des Mittelteils des Roboters zu stark verändert oder dieser spürbar die Neigung zum Horizont verändert, wird der Agent bestraft
    
    \item Insgesamt soll keine Übertragung des implementierten Modells auf den realen Roboter stattfinden
    \item wie oben beschrieben wäre eine Implementierung von diversen Sensoren vonnöten, was den Umfang dieser Arbeit deutlich übersteigt
\end{itemize}

\section{Wahl der Simulationsumgebung}
\begin{itemize}
    \item in der Vorgängerarbeit wurde bereits über verschiedene mögliche Simulationsumgebungen geschrieben
    \item die Bedingungen haben sich leicht geändert
    \item eine mögliche Software (MuJoCo) ist mittlerweile nicht mehr kostenpflichtig, was damals einer der Gründe war, die gegen diese Software gesprochen haben
    \item andererseits soll diese Arbeit an die vorangegangene anknüpfen
    \item wenn die Simulationsumgebung gewechselt würde, würde man im Grunde genommen kaum Ergebnisse der Vorgängerarbeit aufgreifen sondern in vielen Gesichtpunkten von 0 beginnen
    \item deshalb soll weiterhin Unity verwendet werden
    \item Unity bietet jedoch die Möglichkeit, die standardmäßige Physics-Engine gegen andere nach dem Plugin-Prinzip auszutauschen
    \item insofern könnte realistisch und mit geringem Aufwand in Betracht gezogen werden, MuJoCo als Physics-Engine in Unity einzubinden, um somit das Ergebnis des Trainings durch eine andere/verbesserte Physiksimulation zu verbessern
    \item auch wäre es möglich, die Ergebnisse der verschiedenen Umgebungen zu vergleichen
    \item da jedoch keine Übertragung auf einen realen Roboter erfolgt, dürfte in diesem Kontext kein spürbarer Unterschied zu beobachten sein / ein beobachteter Unterschied könnte nicht hinsichtlich seiner Aussagekraft eingeordnet werden
\end{itemize}

\section{Geplante Realisierung}
\begin{enumerate}
    \item alte Umgebug und Lernergebnisse des Roboters rekonstruieren; bringt Probleme mit sich, da einige der verwendeten Komponenten einer starken Entwicklung unterliegen/unterlagen, weshalb potenziell Anpassungen vorzunehmen sind, um die alte Umgebung weiterhin verwenden zu können oder die Umgebung auf einen aktuellen Stand der Technik migriert werden sollte, um von Verbesserungen im verwendeten Tooling zu profitieren und eine zukunftssichere Basis zu bieten
    \item Format entwerfen, wie dem Roboter ein Pfad mitgeteilt werden kann, dem dieser folgen soll; ein Pfad wird hierbei voraussichtlich aus mehreren Punkten bestehen, die sich entlang seines Verlaufs befinden
    \item Belohnungsfunktion anpassen; oben erwähnt Anpassungen hinsichtlich Laufstabilität; außerdem muss ein Abweichen vom direktesten möglichen Weg bestraft werden / zu einer ausbleibenden oder sehr geringen Belohnung führen
    \item Hindernisse ergänzen; hierfür sollte die Kollisionserkennung der Unity-Engine verwendet werden können; mithilfe des Hinzufügens von Kollisionsmodellen für in der Simulationsumgebung platzierten Objekte, sollte der Roboter automatisch nicht mehr durch Hindernisse hindurch gehen können; größte Herausforderung sollte hier die Adaption der Belohnungsfunktion werden, damit diese den Roboter nicht daran hindert, den Pfad zu verlassen, das Hindernis zu umgehen und anschließend auf den Pfad zurückzukehren und eine deutlich gesteigerte Belohnung zu erhalten; gleichzeitig darf der Roboter sich nicht zu frei im Raum bewegen, sondern sollte so dicht wie möglich am vorgegebenen Pfad bleiben
\end{enumerate}